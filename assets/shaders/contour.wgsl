// Animated contour topographic material (unlit style)
// Assumes mesh vertex positions are in model space with Y = height.
// Generated by ContourMaterial (see contour_material.rs)

struct ContourParams {
    min_height: f32,
    max_height: f32,
    interval: f32,
    thickness: f32,
    time: f32,
    scroll_speed: f32,
    darken: f32,
    palette_len: u32,
}

struct ContourPalette {
    colors: array<vec4<f32>, 8u>, // length literal as u32
}

// Bindings autogenerated by AsBindGroup on ContourMaterial fields
@group(2) @binding(0) var<uniform> ContourMaterial_params: ContourParams;
@group(2) @binding(1) var<uniform> ContourMaterial_palette: ContourPalette;

// -------- Bevy mesh pipeline inputs/outputs --------

// Vertex output / fragment input (from core PBR vertex shader)
struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) world_position: vec3<f32>,
    @location(1) world_normal: vec3<f32>,
    // Remaining locations ignored for this unlit custom fragment
    // (We only need world position.y for height-based coloring.)
};

struct FragmentOutput {
    @location(0) color: vec4<f32>,
};

// Helper: fetch palette color with safe index (clamp)
fn palette_color(idx: u32) -> vec3<f32> {
    return ContourMaterial_palette.colors[min(idx, 7u)].rgb;
}

// Elevation band interpolation
fn band_color(norm_h: f32) -> vec3<f32> {
    let len = max(1u, ContourMaterial_params.palette_len - 1u);
    let fidx = norm_h * f32(len);
    let i0 = u32(clamp(floor(fidx), 0.0, f32(len - 1u)));
    let t  = clamp(fidx - f32(i0), 0.0, 1.0);
    let c0 = palette_color(i0);
    let c1 = palette_color(i0 + 1u);
    return mix(c0, c1, t);
}

// Contour line mask (0..1) using height interval + animated offset.
fn contour_mask(world_h: f32) -> f32 {
    let interval = max(0.0001, ContourMaterial_params.interval);
    let scroll = ContourMaterial_params.time * ContourMaterial_params.scroll_speed;
    // Fractional position within interval (animated)
    let frac = fract((world_h + scroll) / interval);
    // Distance to nearest line (line at 0 boundary)
    let d = min(frac, 1.0 - frac);
    let thickness = ContourMaterial_params.thickness;
    // Soft line: invert & shape
    let m = clamp(1.0 - d / thickness, 0.0, 1.0);
    return pow(m, 1.5);
}

@fragment
fn fragment(in: VertexOutput) -> FragmentOutput {
    let params = ContourMaterial_params;

    // Normalize height to 0..1
    let denom = max(0.0001, params.max_height - params.min_height);
    let norm_h = clamp((in.world_position.y - params.min_height) / denom, 0.0, 1.0);

    // Base elevation color
    var col = band_color(norm_h);

    // Contour lines
    let line_m = contour_mask(in.world_position.y);

    // Ink color (dark neutral, slight warm)
    let ink = vec3<f32>(0.15, 0.13, 0.11);
    col = mix(col, ink, line_m * 0.85);

    // Optional global darken
    col *= params.darken;

    // Minor slope darkening for definition
    let n = normalize(in.world_normal);
    let slope = clamp(n.y, 0.0, 1.0);
    col *= (0.85 + 0.15 * pow(slope, 0.6));

    return FragmentOutput(vec4<f32>(col, 1.0));
}
